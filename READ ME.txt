
                         /* - / HEADER CONVERTER / - */
                              Autor: CyndxTs o.0?!
                                  Version: 2.0

Este programa est치 principalmente ideado para transcribir directamente archivos
".cpp" hacia archivos '.h'! Adem치s, se supone que tambi칠n funciona para ordenar
un mismo '.h', nada te impide probar.. Para resumir la utilidad del programa,
ya no tendr치s que estar copiando funci칩n a funci칩n cada cabezera para hacer tu
header. Adem치s, por si no fuera poco, este programa a침ade varios controladores
para realizar diferentes ajustes adicionales! Por ejemplo, la supresi칩n de
variables de los par치metros de las funciones en definici칩n, el ajuste de
cabezeras al margen de p치gina, y muchas m치s!

	    * Intento de Indice *											   #Fila
  [#] TITULO & INTRODUCCION & INDICE		...............................  002
  [#] RESUMEN DE NOVEDADES					...............................  027
  [#] VOCABULARIO							...............................  069
  [#] CONTROLADORES GENERALES				...............................  103
  [#] CONTROLADORES DE ASIGNACIONES			...............................  269
  [#] CONTROLADORES DE FUNCIONES			...............................  307
  [#] ACLARACIONES DE FORMATO				...............................  472
  [#] SUGERENCIAS ANTI-ERRORES				...............................  537
  [#] FAQ & COSITAS				            ...............................  588
________________________________________________________________________________
================================================================================
                              RESUMEN DE NOVEDADES
--------------------------------------------------------------------------------
[#] Version 2.0:

	[+] Ahora el programa puede validar por su cuenta la posibilidad de palabras
		claves compuestas, asignaciones predefinidas en par치metros de funciones,
		y sobrecargas de operadores.

	[+] Ahora el usuario puede elegir que operadores segmentan a los de operandos
		de 'Asignacion' y subOperandos de 'Funcion'. Es decir, ahora podr치s
		elegir que operadores se espacian entre los operandos.
		EJM:
			'+' => {Segmentacion = true}
				INPUT:  int suma=a+b;
				OUTPUT:	int suma = a + b;
			'/' => {Segmentacion = false}
				INPUT:  int fraccion=a / b;
				OUTPUT:	int fraccion = a/b;
		Disclaimer: Los subOperandos dentro de otros agrupadores simplemente se
					ajustaran/comprimiran dentro de estos.

	[+] Ahora las declaraciones se podr치n ordenar independiente o
		simultaneamente por cada Tipo de Ordenamiento.
			"{Tipo de Declaracion} || {KeyWord} || {Identificador}"

	[+] Se agregaron nuevos warnings, y se modifico la descripci칩n de las
		acciones recomendadas de estos en la consola. Adem치s, ahora solo algunos
		cancelaran la ejecuci칩n del programa.

	[+] Se agregaron comentarios precisos a los archivos ".h" con el fin de
		poder agilizar el entendimiento de los controladores del programa.

	[+] Se modific칩 la declaraci칩n de "LSE" con el fin de tener una mayor
		eficiencia en casos en donde no se precise ordenar las declaraciones.
		[|] Cambio de Identificador: "LSE" -> "LDX"
		[+] Nuevo atributo: final [Tipo: Nodo *]

	[-] Por el momento, se decidi칩 descartar la funci칩n de ajuste hacia margen
		en 'subElementos'. Es decir, ya no se maneja una 'subApertura' en las
		declaraciones.
________________________________________________________________________________
================================================================================
                                  VOCABULARIO
--------------------------------------------------------------------------------
  [#] "Declaracion"
	  Funci칩n o Asignaci칩n independiente. Es decir, que no sea definida dentro
	  de otra funci칩n o clase.
  [#] "KeyWord"
	  Tambi칠n conocidas como 'Palabra clave' o 'Palabra Reservada', son palabras
	  con funcionalidades especiales (Como idenfiticadores de tipo de dato o
	  inicializadores de estructuras de control). Aunque, almenos para este
	  programa se las utiliza para ubicar las declaraciones.
  [#] "Identificador"
	  Cadena de caracteres que simboliza el nombre de alguna variable,'KeyWord',
	  'Operando', etc.
  [#] "Modificador"
	  Caracter que varia el tipo de dato hacia puntero o direcci칩n de memoria
	  del tipo descrito.
  [#] "Agrupador"
	  Caracter que encierra uno o varios elementos.
  [#] "Aperturador" & "Delimitador"
	  Agrupadores de 'Apertura' y 'Cierre', respectivamente.
  [#] "Espaciador"
	  Caracter que se usa para separar caracteres en archivos de texto.
  [#] "Separador"
	  Caracter que se usa para diferenciar a un elemento de un conjunto de un
	  agrupador o declaracion.
  [#] "Sentencia"
	  Grupo de elementos que conformen un tipo de dato predefinido. Por ejemplo,
	  todos los elementos de un par치metro en conjunto. [KeyWord + Identificador]
  [#] "Nivel" & "SubNivel"
	  Cantidad de Aperturadores previos a la posici칩n en la que se encuentre el
	  elemento. Por ejemplo, en "char what = cad[arr['#'][2]];", el '#' esta en
	  el tercer 'subNivel' de aperturas, y en el cuarto 'nivel' de aperturas.
________________________________________________________________________________
================================================================================
                            CONTROLADORES GENERALES
--------------------------------------------------------------------------------
[#] "ajustarPorMargen" [Tipo: const bool]
	Cuando est치 habilitado, las sentencias pasan autom치ticamente a la siguiente
	linea en su posicion de apertura respectiva cuando se alcanza el margen de
	p치gina preestablecido. Cuando est치 deshabilitado (o si el ajuste es en el
	primer caracter despues de la apertura de la declaracion), simplemente las
	sentencias seguiran su curso por la misma linea independientemente de como
	sea en el archivo fuente.

	[|] "limitePorMargen" [Tipo: const int]
		Indica la cantidad de caracteres hasta el margen de Pagina deseado.
		Para el caso est치ndar, este margen aparece despu칠s de 80 caracteres
		(NO ESPECIALES).

[#] "ordenarDeclaraciones" [Tipo: const bool]
	Cuando est치 habilitado, las declaraciones se imprimiran ordenadas conforme
	al valor del controlador de los criterios de ordenamiento. Cuando est치
	deshabilitado, simplemente se imprimir치n conforme se lean del archivo
	fuente.

	[|] "criteriosDeOrdenamiento" [Tipo: const char[4]]
	Indica el tipo de Ordenamiento con el que se imprimiran las declaraciones
	obtenidas del archivo fuente. Los valores para estos son conforme a las
	letras: ['A'scendente | 'D'escendente | 'C'onsecuente]
	Estos se deben colocar segun la posici칩n de los criterios a evaluar:
			   "{Tipo de Declaracion} {KeyWord} {Identificador}"
--------------------------------------------------------------------------------
CASO DE USO A:	/* Se indica la posicion del margen de pagina con "-|" */

Controladores: [ajustarPorMargen = true][limitePorMargen = 10]

                                  >> INPUT <<

         -|
int sumarEpicamente(int a,int b,int c){
	return a+b+(int)'e'+(int)'p'+(int)'i'+(int)'c';
}

                                  >> OUTPUT <<

[#] >> WARNING POR IGNORAMIENTO DE LIMITE

         -|
int sumarEpicamente(int a,int b,int c);
--------------------------------------------------------------------------------
CASO DE USO B:

Controladores: [ajustarPorMargen = false][limitePorMargen = 10]

                                  >> INPUT <<

         -|
int sumarEpicamente(int a,int b,int c){
	return a+b+(int)'e'+(int)'p'+(int)'i'+(int)'c';
}

                                  >> OUTPUT <<

         -|
int sumarEpicamente(int a,int b,int c);
--------------------------------------------------------------------------------
CASO DE USO C:

Controladores: [ajustarPorMargen = true][limitePorMargen = 32]

                                  >> INPUT <<

                               -|
int sumarEpicamente(int a,int b,int c){
	return a+b+(int)'e'+(int)'p'+(int)'i'+(int)'c';
}

                                  >> OUTPUT <<

                               -|
int sumarEpicamente(int a,int b,
				    int c);
--------------------------------------------------------------------------------
CASO DE USO D:

Controladores: [ordenarDeclaraciones = true][criteriosDeOrdenamiento = "ADA"]
/*
                      {Ascendente por Tipo de Declaracion}
                           {Descendente por KeyWord}
                         {Ascendente por Identificador}
*/

                                  >> INPUT <<

int algo_1 = queso[1];
int algo_3 = queso[3];
int algo_2 = queso[2];
const char queque2 = ';';
const char queque3 = ')';
char queque1 = ']';
bool como_1 = a;
bool como_3 = c;
bool como_2 = b;
int algoInt_1(int a){
	return a+(int)'a'-(int)'l'*(int)'g'/(int)'o';
}
int algoInt_3(int a,int b,int c){
	return a-b*c/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}
int algoInt_2(int a,int b){
	return a*b/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}
char algoChar_3(int a,int b,int c){
	return a-b*c/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}
char algoChar_1(int a,int b,int c){
	return a+b+(int)'e'+(int)'p'+(int)'i'+(int)'c';
}
const char algoChar_2(int a,int b,int c){
	return a*b/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}
void algoVoid_1(int &a){
	a = (int)'e'+(int)'p'+(int)'i'+(int)'c';
}
void algoVoid_3(int &a,int b,int c){
	a = b*c/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}
void algoVoid_2(int &a,int b){
	a = b/(int)'a'+(int)'l'-(int)'g'*(int)'o';
}

                                  >> OUTPUT <<

int algo_1 = queso[1];

int algo_2 = queso[2];

int algo_3 = queso[3];

const char queque2 = ';';

const char queque3 = ')';	// Notar que "const char" > "char"

char queque1 = ']';

bool como_1 = a;

bool como_2 = b;

bool como_3 = c;

void algoVoid_1(int &a);

void algoVoid_2(int &a,int b);

void algoVoid_3(int &a,int b,int c);

int algoInt_1(int a);

int algoInt_2(int a,int b);

int algoInt_3(int a,int b,int c);

const char algoChar_2(int a,int b,int c);	// Notar que "const char" > "char"

char algoChar_1(int a,int b,int c);

char algoChar_3(int a,int b,int c);
________________________________________________________________________________
================================================================================
                         CONTROLADORES DE ASIGNACIONES
--------------------------------------------------------------------------------
[-] "procesarAsignaciones" [Tipo: const bool]
Cuando est치 habilitado, se procesar치n las asignaciones declaradas en el archivo
fuente. Si est치 deshabilitado, las asignaciones no se procesar치n ni
transcribir치n.
--------------------------------------------------------------------------------
CASO DE USO A:

Controladores: [procesarAsignaciones = false]

                                  >> INPUT <<

const int numQuesos =   10  ;

const char especimenID[ 10 ] =  "0x983" ;

                                  >> OUTPUT <<

[#] >> WARNING POR ARCHIVO VACIO
--------------------------------------------------------------------------------
CASO DE USO B:

Controladores: [procesarAsignaciones = true]

                                  >> INPUT <<

const int numQuesos =   10  ;

const char especimenID[ 10 ] =  "0x983" ;

                                  >> OUTPUT <<

const int numQuesos = 10;

const char especimenID[10] = "0x983";
________________________________________________________________________________
================================================================================
                           CONTROLADORES DE FUNCIONES
--------------------------------------------------------------------------------
[#] "procesarFunciones" [Tipo: const bool]
Cuando est치 habilitado, se procesar치n las funciones declaradas en el archivo
fuente. Si est치 deshabilitado, las funciones no se procesar치n ni se
transcribir치n.

	[|] "suprimirVariables" [Tipo: const bool]
	Cuando est치 habilitado, los identificadores de las variables de los
	par치metros de la funci칩n no ser치n procesados en la conversi칩n. Si est치
	deshabilitado, se considerar치n los identificadores y ser치n transcritos
	normalmente.

	[|] "simboloDelimitador" [Tipo: const char]
	Caracter espec칤fico con el cual se finaliza la impresi칩n de una funci칩n.
	Por ejemplo, puedes poner ';' para los archivos ".h", y '{' para ordenar las
	cabezeras de tu archivo ".cpp".
--------------------------------------------------------------------------------
CASO DE USO A:

Controladores: [mostrarFunciones = false]
			   {[suprimirVariables = false][simboloDelimitador = 'a']}

                                  >> INPUT <<

bool esFemboy(int edad   , char genero){
	return (edad > 15 and genero == 'M' and strcmp(gustoMusical,"Kpop") == 0);
}

bool puedeChambear (  int    edad ){
	return edad >= 18;
}

bool esPeruano(char color){
	return     color ==  'C';
}

void mostrarDerechos( struct  Persona  usu  ){
	if(not(esPeruano(usu.color) and strcmp(usu.apellido,"Quispe") == 0)){
		imprimirConstitucionNazi();
	}else{
		cout<<"..."<<endl;
		exit(1);
	}
}

                                  >> OUTPUT <<

[#] >> WARNING POR ARCHIVO VACIO
--------------------------------------------------------------------------------
CASO DE USO B:

Controladores: [mostrarFunciones = true]
			   {[suprimirVariables = false][simboloDelimitador = ';']}

                                  >> INPUT <<

bool esFemboy(int edad   , char genero){
	return (edad > 15 and genero == 'M' and strcmp(gustoMusical,"Kpop") == 0);
}

bool puedeChambear (  int    edad ){
	return edad >= 18;
}

bool esPeruano(char color){
	return     color ==  'C';
}

void mostrarDerechos( struct  Persona  usu  ){
	if(not(esPeruano(usu.color) and strcmp(usu.apellido,"Quispe") == 0)){
		imprimirConstitucionNazi();
	}else{
		cout<<"..."<<endl;
		exit(1);
	}
}

                                  >> OUTPUT <<

bool esFemboy(int edad,char genero);

bool puedeChambear(int edad);

bool esPeruano(char color);

void mostrarDerechos(struct Persona usu);
--------------------------------------------------------------------------------
CASO DE USO C:

Controladores: [mostrarFunciones = true]
			   {[suprimirVariables = true][simboloDelimitador = ';']}

                                  >> INPUT <<

bool esFemboy(int edad   , char genero){
	return (edad > 15 and genero == 'M' and strcmp(gustoMusical,"Kpop") == 0);
}

bool puedeChambear (  int    edad ){
	return edad >= 18;
}

bool esPeruano(char color){
	return     color ==  'C';
}

void mostrarDerechos( struct  Persona  usu  ){
	if(not(esPeruano(usu.color) and strcmp(usu.apellido,"Quispe") == 0)){
		imprimirConstitucionNazi();
	}else{
		cout<<"..."<<endl;
		exit(1);
	}
}

                                  >> OUTPUT <<

bool esFemboy(int,char);

bool puedeChambear(int);

bool esPeruano(char);

void mostrarDerechos(struct Persona);
--------------------------------------------------------------------------------
CASO DE USO D:

Controladores: [mostrarFunciones = true]
			   {[suprimirVariables = false][simboloDelimitador = '{']}

                                  >> INPUT <<

bool esFemboy(int edad   , char genero){
	return (edad > 15 and genero == 'M' and strcmp(gustoMusical,"Kpop") == 0);
}

bool puedeChambear (  int    edad ){
	return edad >= 18;
}

bool esPeruano(char color){
	return     color ==  'C';
}

void mostrarDerechos( struct  Persona  usu  ){
	if(not(esPeruano(usu.color) and strcmp(usu.apellido,"Quispe") == 0)){
		imprimirConstitucionNazi();
	}else{
		cout<<"..."<<endl;
		exit(1);
	}
}

                                  >> OUTPUT <<

bool esFemboy(int edad,char genero){

bool puedeChambear(int edad){

bool esPeruano(char color){

void mostrarDerechos(struct Persona usu){
________________________________________________________________________________
================================================================================
                            ACLARACIONES DE FORMATO
--------------------------------------------------------------------------------
[#] Escritura "inclusive":
	Este programa se estandariz칩 de manera que es independiente de la forma de
	codificar de cada uno de ustedes. Por ejemplo, pueden escribir "const int *"
	de cualquier manera con tal que el compilador lo valide; es decir, almenos
	para este ejemplo, podr칤an escribir "const int*" o "const int          *   "
	y no habr칤a ningun problema.

[#] Agrupacion por Elementos vs Agrupaci칩n por Sentencias:
	Las inicializaciones de arreglos por "{}" se ajustan por cada elemento de
	primer nivel. Por ejemplo, si se tiene:
					char vocales[5] = {'a','e','i','o','u'};
	Los elementos de primer nivel son cada una de las letras incluyendo a las
	comillas y comas. No obstante, si se tiene un arreglo de arreglos, entonces
	el primer nivel de elementos de estos ser칤a una 'sentencia'. Por ejemplo, si
	se tiene:
					int triadas[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
	Ahora el elemento los elementos de primer nivel son cada triada incluyendo
	las comillas, comas y llaves. Entonces, en caso de algun ajuste de margen,
	lo que bajar치 ser치 toda la triada como sentencia. Por ejemplo, "{7,8,9}};".
	Cabe resaltar que el programa no reajusta a un mismo elemento m치s de una
	vez, por lo que si la sentencia o elemento se excede del margen de p치gina,
	se mantendr치 as칤, pues en realidad se ve mejor de esta forma..

[#] Operadores en Asignaciones:
	Existen casos muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuy raros en los cuales
	se asignan valores constantes en los archivos ".cpp" como el resultado de
	una funci칩n con uno que otro valor adicional. Para estos casos, el programa
	toma el ajuste a margen otra vez hacia el primer nivel. Adem치s, los
	operandos de la signaci칩n y los subOperandos de las funciones de primer
	nivel utilizadas aqu칤 se segmentar치n para dar un mejor estilo.
	[|]EJEMPLO:

                                  >> INPUT <<

const int  * numVida[18][queso] = dameAlgoRaro('a'*12+2.5-abc,
										arr[12+';' 
  									     	]) or 12-1;

                                  >> OUTPUT <<

const int *numVida[18][queso] = dameAlgoRaro('a'*12 + 2.5 - abc,arr[12+';']) or
                                12 - 1;

[#] Asignaciones en Par치metros:
	Una de las features implica a que se puedan inicializar par치metros. Por
	ello, el formato de esta parte es b치sicamente la misma que la de los
	operadores en asignaciones.
	[|]EJEMPLO:

                                  >> INPUT <<

void ola(const int *palabra[';']['a']=12+vida(abc[12][12]+12*15+7+1)){
	cout<<"bai bai * mewing *";
	cout<<endl;
}

                                  >> OUTPUT <<

void ola(const int *[';']['a'] = 12 + vida(abc[12][12] + 12*15 + 7 + 1));

	   /*Si no te sale algo, la verdad no se que pudieses haber puesto xD*/
________________________________________________________________________________
================================================================================
                            SUGERENCIAS ANTI-ERRORES
--------------------------------------------------------------------------------
[#] Configuraci칩n de Controladores Recomendada.
	Asumiendo que el 99.937% de la gente que lea esto, no habr치 le칤do todo lo de
	arriba, les dejo los valores de "f치brica" de los controladores para que as칤
	puedan usar el programa r치pidamente..

				{ajustarPorMargen = true}
				{limitePorMargen = 80}
				{ordenarDeclaraciones = true}
				{criteriosDeOrdenamiento = "ACC"}

				{procesarAsignaciones = true}

				{procesarFunciones = true}
				{suprimirVariables = true}
				{simboloDelimitador = ';'}

[#] A침adir los identificadores de nuevas TADS en el diccionario de keywords. En
	caso uses "typedef" o simplemente definas una "struct". Debes a침adir este
	nuevo identificador al arreglo de "Keywords" con el formato preestablecido,
	pues la ubicacion de declaraciones se hace hasta encontrar una nueva palabra
	clave como "int" o "const" para poder continuar. Por ello si no agregas el
	nuevo identificador, no se podr칤a diferenciar de una palabra cualquiera del
	archivo, o incluso saltar algun error de partici칩n.

[#] Corroborar el tama침o de tus idenfiticadores.
	Los idenfiticadores de los par치metros, palabras clave, operadores, etc.
	Tienen tama침os distintos, porque se agrupan de manera distinta. Por ello,
	deber치s acceder al archivo "declaraciones.h" para verificarlo y as칤 no tener
	un error de capacidad de memoria.

[#] Corroborar los Comentarios
	Se ha validado en las situaciones necesarias la posible existencia de
	comentarios que puedan alterar la secuencia del programa, no obstante,
	siempre puede haber un caso por ah칤 que no se haya tomado en cuenta.

[#] Mandar programas correctos.
	Este programa valida varias formas de escribir, pero todas son validadas por
	el compilador de C++, por lo que, obviamente, no va a funcionar si se mandan
	cosas como "bool queso int papaNoel esNavidadAssembler(que,bool)--".
	No obstante, uno que otro warning interrumpir치 el programa para reportar un
	error, pero enfatizando el punto anterior, puede ser que haya un caso por
	ah칤 que no se haya tomado en cuenta.

[#] Espacios >> Tabs
	Preferiblemente, para un buen funcionamiento del programa, se recomienda
	usar espacios en lugar de los tabs en los archivos, pues seguro una que otra
	validacion aun no est치 100% asegurada con respecto a estos.
________________________________________________________________________________
================================================================================
                                 FAQ & COSITAS
--------------------------------------------------------------------------------
En caso tengas problemas con el programa, o consideres que faltan funciones,
puedes encontrarme en el discord de inform치tica!

				  INF Syndicate游냖: https://discord.gg/YMhYSs2PP3

[-] DISCLAIMER A:
	Obviamente existen millones de casos en los que se puede escribir un
	programa en este lenguaje, y que justo de los justos seas m치s salado que
	caf칠 con sal y tu forma no est칠 validada por el programa.. El programa se
	hizo pensando en DEMASIADOS casos a mi parecer, y bueno, si faltan alguno..
	dimelo! Aunque cabe resaltar que los casos mencionados en las aclaraciones
	NO son errores, sino que, almenos a mi parecer, ese formato es el m치s
	ordenado. Adem치s que es medianamente est치ndar para un p칰blico general..

[-] DISCLAIMER B:
	Ya se que en algunos casos la modulaci칩n y complejidad del programa no es la
	mejor.. esto se ir치 mejorando en futuras versiones.. o no xd
	Pero por favor, 30ms - 80ms en promedio para transcribir 40 funciones es
	muy bueno a mi parecer!

FAQ:

Q: 	Mucho texto.jpg 쮺ual seria la configuracion est치ndar?
A: 	[ajustarPorMargen = true][limiteMargen = 80][ordenarDeclaraciones = true]
	[tipoOrdenamiento = "ACC"][procesarAsignaciones = true]
	[procesarFunciones = true][suprimirVariables = true]
	[simboloDelimitador = ';']

Q: 	쯃o puedo compartir?
A: 	jaja como si valiera xD El programa es de uso libre! Si lo comparten, ser칤a
	chevere que me mencionen o almenos compartan el discord para que pueda
	llegar a m치s gente!
	
Q:  No me gusta el formato de ordenamiento.. 쮺칩mo lo cambio?
A:	Haciendo tu propio programa! :thumbs-up:!
	Ehh, como mencion칠, el formato es predeterminado por obvias razones, y lo
	hice de una manera est치ndar para que les pueda servir a todos.. Aunque,
	almenos a mi parecer, con el buen uso de los controladores deber칤a ser
	suficiente.
	
Q:  Estoy en un nivel m치s avanzado y uso m치s palabras claves a las predefinidas.
	쯃as debo agregar?쯖칩mo lo hago?
A:	Claro que s칤! Literalmente es lo que mencion칠 en las sugerencias..
	Bueno, en resumen, simplemente a침ade tu TAD o nueva KW a la lista de KW.
	
Q:  쮻칩nde y c칩mo enviar치s las actualizaciones?
A:	Simplemente mandar칠 el programa actualizado en formato zip a trav칠s del
	discord mencionado anteriormente. Considero que es lo m치s f치cil por ahora.

Q: 	Pero.. 쯘res o no eres?
A:	Esas preguntas no me dejan dormir de noche.jpg

Q:	쮺uando subir치s un nuevo v칤deo a tu canal de Youtube?
A:	Bueno! creo que acabamos con las preguntas u-u!

                              Autor: CyndxTs o.0?!
                                  Version: 2.0
================================================================================
